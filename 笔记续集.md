*2025.8.21*
## 杂项
1. 之前我们打印错误信息一般是  
```c 
printf("%s\n",strerror(errno)); 
```
实际上可以使用函数perror
```c 
perror("错误是");
```
如果真的有错误，就会打印"错误是"+  :  + 错误信息。这就比之前方便许多。
2. "格式化"指的是数据在存储介质（如文件）和程序内存之间转换时，需要遵循的结构约定或表示规范。比如
```c
 // 格式化写入：将二进制数据转换为特定格式的文本
    fprintf(pf, "姓名：%s，年龄：%d，工资：%.2f\n", name, age, salary);
```
3. fprintf输入中文时出错，原因暂且不明。
4. Q：我们说printf是打印，scanf是输入，怎么到文件就反过来了？
A：实际上，printf是**从程序中读取数据**打印出来，scanf是**从外部读取数据到程序**；而把文件视为外部是不是就合理了。一般都是以程序作为第一人称。
![alt text](image-5.png)
#### 4.文件的顺序读写
![alt text](image.png)
可以看到，对于文件的读写，不仅仅有顺序的不同，还有一次读写多少，按什么形式读写的区别。
下面演示一下：
```c

#include<string.h>
#include<stdio.h>
#include<errno.h>
int main()
{
	FILE* pf = fopen("test.txt", "w");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//打开成功
	//读写文件


	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```
这就是使用一个文件的大概框架，包含打开，读写，关闭。
Q：为什么需要关闭，不关闭会怎么样？
A：不关闭会占用内存空间，而且不关闭文件可能会对里面的数据造成威胁。现在我们单独拿出读写文件的部分
##### fputc or fgetc
```c
//读写文件
//根据上表，我需要写文件，所以应该使用输出类的函数。
fputc('a',pf);

```
![alt text](image-1.png)
这里成功写入了'a'。关于文件写入具体运作方式我还发现了一些有意思的现象，关于使用文件整个过程不同阶段文件内容的变化，和同一程序多次输入和多次运行程序的不同，不过我猜之后会讲到。
解答：
A：以写入的方式打开文件，如果里面有内容，会 先把内容清空。
Q: 如果我不想清空呢？
A：请用'a'打开，也就是追加。
下面试试读文件吧
```c
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
//打开成功
//读写文件
//这里需要输入类函数
char c = fgetc(pf);
printf("%c\n",c);
```
因为这里需要读而不是写，所以就要更改打开文件的方式。
![alt text](image-2.png)
有意思的是，如果我先多次输入一些内容，然后多次读取，每次读取的内容不是第一个输入的内容，而是向后顺延。
```c
#define _CRT_SECURE_NO_WARNINGS
#include<string.h>
#include<stdio.h>
#include<errno.h>
int main()
{
	FILE* pf = fopen("test.txt", "w");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//打开成功
	//读写文件
	char i = 0;
	for (i = 'a';i <= 'z';i++)
	{
		fputc(i, pf);
	}
	//关闭文件
	fclose(pf);
	pf = NULL;
	pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//打开成功
	//读写文件
	//这里需要输入类函数
	char c = (char)fgetc(pf);
	printf("%c\n", c);	
	c = (char)fgetc(pf);
	printf("%c\n", c);
	c = (char)fgetc(pf);
	printf("%c\n", c);
	c = (char)fgetc(pf);
	printf("%c\n", c);
	c = (char)fgetc(pf);
	printf("%c\n", c);
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
![alt text](image-3.png)
我不禁设想，难道有一个神秘的计数器，能记录本次运行程序读的次数？
有一个要注意的点，如果读取失败，会返回EOF，所以可以加上一个判断EOF，以保证顺利运行。
##### fputs or fgets
下面试试写一行的数据，也就是fputs函数
![alt text](image-4.png)
```c
	FILE* pf = fopen("test.txt", "a");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//打开成功
	//读写文件
    fputs("hello world",pf);

	//关闭文件
	fclose(pf);
	pf = NULL;
```
注意这里用的是追加的打开方式。我运行了两次。
![alt text](image-6.png)
下面使用一次读取一行的函数fgets![alt text](image-7.png)
其实讲了3个这些函数大致规律也比较清晰了，指针是读写必须。读写失败返回值如果是指针就返回NULL，如果是整形就返回EOF。
```c
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//打开成功
	//读写文件
    char arr[13];//用于接收
    fgets(arr,5,pf);//看似是读5个字符，其实算上'\0'真正读了4个

	//关闭文件
	fclose(pf);
	pf = NULL;
```
![alt text](image-8.png)
##### fprintf or fscanf
讲这么多，这个文件读写函数还是只能以字符或字符串的形式，而要实现别的形式的读写，需要用格式化的读写。
fprintf是写文件，fscanf是读文件。
Q：我们说printf是打印，scanf是输入，怎么到文件就反过来了？
A：实际上，printf是**从程序中读取数据**打印出来，scanf是**从外部读取数据到程序**；而把文件视为外部是不是就合理了。
![alt text](image-9.png)
可以看出，相比于printf只多了一个文件指针。
```c
typedef struct S
{
	char name[13];
	int age;
}SS;

int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "w");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读写文件
	SS Z = { "zhangsan",21};
	fprintf(pf, "%s %d", Z.name, Z.age);

	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
再来试试格式化的读取
![alt text](image-10.png)
与scanf的参数也是非常的接近
```c
typedef struct S
{
	char name[13];
	int age;
}SS;

int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读写文件
	SS Z = {0};
	fscanf(pf,"%s %d",Z.name,&(Z.age));

	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
![alt text](image-11.png)
Q：为什么就识别成“zhangsan”和21，而不是“zhangsan 21”？
A：不知道啊

#### 流
![alt text](image.png)
Q：上图的最右边，适用于什么什么流是什么意思，流又是什么？
A：流可以理解成程序与外界信息的交界地。
如果对外界的读写如下图：
![alt text](image-12.png)
对于不同的对象，读写方式肯定不同，也就是说对于不同的对象，程序员需要用不同的方式读写，学习成本很高。
所以流出现了。
![alt text](image-14.png)
如图，通过流，就可以将我们输出或输入的数据转化为对应的形态。而流内部怎么转化，是底层帮我们实现的。
所以这些函数有的不仅仅面向于文件，而调用这些函数传入的用于读写的指针，就称为流。
![alt text](image-17.png)
所以我们现在使用的计算机，都是通过流进行读写（存疑）。流就像运河，开闸才能通行。我们为什么运行C程序时，能使用键盘，亮起屏幕，因为与这些相关的流默认开启
![alt text](image-15.png)
为什么使用文件要有一个打开的过程，这个过程就是开闸的过程。
按照上面的理论，fprintf是适应所有流的，那么是不是可以输出到屏幕上。
![alt text](image-16.png)
可以看到，之前使用fprintf是使用文件流，我改成了“stdout”屏幕的流，结果是打印到了屏幕上
> AI:
> 缓冲区与流的关系
您提出了一个很好的观察！缓冲区和流确实是密切相关但又有所区别的概念。它们经常一起工作，但并非完全相同的概念。
>- 缓冲区 vs. 流：区别与联系
>1. 本质
缓冲区 (Buffer)：内存中的一块区域
流 (Stream)：数据的抽象流动通道
>2. 功能
缓冲区 (Buffer)：临时存储数据
流 (Stream)：提供数据流动的路径和接口
>3. 比喻
缓冲区 (Buffer)：水池或水库
流 (Stream)：河流或管道
>4. 关注点
缓冲区 (Buffer)：数据的暂存和管理
流 (Stream)：数据的传输和方向
>5. 物理性
缓冲区 (Buffer)：具体的内存区域
流 (Stream)：抽象的概念接口
>- 缓冲区 (Buffer)
是实际的内存区域，用于临时存储数据
目的是平衡速度差异（如快速CPU与慢速I/O设备）
可以是硬件缓冲区或软件缓冲区
示例：键盘缓冲区、磁盘缓存、视频缓冲区
>- 流 (Stream)
是数据的抽象流动概念
提供统一的接口来处理各种输入/输出设备
关注的是数据流动的方向和方式
示例：标准输入流(stdin)、标准输出流(stdout)、文件流

##### fread 和 fwrite
这两个函数区别于其他函数适用于所有流。这两个函数只适用于文件流，也就是只能实现对文件的读写。而且不仅仅只能拿对文件读写，还只能以二进制的形式对文件读写。
![alt text](image-19.png)
![alt text](image-20.png)
```c
typedef struct S
{
	char name[13];
	int age;
}SS;
int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "wb");
	//因为要进行二进制的写，所以要使用"wb"的形式
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读写文件
	SS Z = { "zhangsan",21};
	fwrite(&Z, sizeof(SS), 1, pf);
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
然后打开文件
![alt text](image-18.png)
这正是因为txt文件是以字符形式打开，而我们写入的数据却是二进制形式，所以出现了乱码。
Q：那为什么"zhangsan"不是乱码？
A：因为"zhangsan"二进制和字符呈现的样子都一样。
Q：那么怎么读取里面的信息呢？
A：用二进制输入函数fread。
```c
typedef struct S
{
	char name[13];
	int age;
}SS;
int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "rb");
	//因为要进行二进制的写，所以要使用"wb"的形式
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读写文件
	SS Z = { 0 };
    //刚刚已经输入数据了
	fread(&Z, sizeof(SS), 1, pf);
    printf("%s %d",Z.name,Z.age);
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
![alt text](image-21.png)
可以看到，fread的确提取出了我用二进制输出的数据。
Q：那么我以二进制形式读写和我以文本的形式读写有什么区别呢？
A：老师说以后会讲。
*2025.8.22*
对比一组函数
> fscanf / scanf / sscanf
> fprintf / printf / sprintf

 ![alt text](image-22.png)
 ![alt text](image-23.png)
 ##### sprintf 和 sscanf
 ```c
 int sprintf( char* str, const char* format, ...);
 ```
 将一个格式化的数据输出到一个字符串中。
 ```c
#include<stdio.h>
int main()
{
	int a = 13;
	char arr[8];
	sprintf(arr, "%d", a);
	printf("%s\n", arr);
	return 0;
}
 ```
此函数的本质是将格式化的数据转化为字符串。比如，一个整形13，在计算机眼中其实还有原反补等一系列的意义，使用这个函数相当于剥夺了它的意义，只保留“13”这个字符串。从 13 -> "13"。
![alt text](image-24.png)
当然也可以这样使用，本质都是一样的。
```c
int sscanf(const char* s, const char* format, ..);
```
从一个字符串数据中获取一个格式化的数据
刚刚sprintf的第一个参数是输出到哪里。
那么sscanf的第一个参数想必是从哪里输入，也就是从哪里获取数据。后面就是我们指定的格式,输入到某个地址指向的空间。也就是把"13" -> 13再把13存起来的过程。
```c
struct P
{
	char name[13];
	int age;
};
int main()
{
	struct P a = { "zhongyuanxia",17 };
	struct P b = { 0 };
	char buf[21];
	sprintf(buf, "%s %d", a.name, a.age);
	printf("%s\n", buf);
	sscanf(buf, "%s %d", b.name, &(b.age));
	return 0;
}
```
![alt text](image-25.png)
可以看到，成功从字符串buf中获取格式化的数据到我指定的空间了。这两个函数不针对任何流。
Q：为什么这么说？
A：我觉得是不管是获取数据的地方，还是输出数据的地方，都在程序内部完成，所以与外界连通的流无关。
所以，printf类函数与scanf类函数还真是相辅相成呢。
甚至说，自然界的一切视觉，都是字符串，听觉，触觉也是，我们通过 【脑】从自然界解读信息，还有将【脑】中的信息转化为语言，动作，的能力。
了解这些之后，关于sprintf与sscanf的应用场景也能想到，在一个程序内，如果有面向人类的字符串数据，就一定需要sscanf去解读成计算机理解的数据。同时如果要把计算机数据呈现给人类，就需要sprintf。

##### 通讯录（文件的版本）
*2025.8.24*


#### 5.文件的随机读写

##### 5.1 fseek(移动文件指针)
```c
int fseek(FILE* stream,long int offset,int origin);
```
运动都是相对的，准确的移动一定有参照物。第三参数origin用来确定参照物，第二参数确定偏移量(移动距离)。
下面我来演示怎么通过fseek移动文件指针读到指定文本。
```c
int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//使用文件
	//移动文件指针
	fseek(pf ,2 , SEEK_SET);
	int ch = fgetc(pf);
	printf("%c\n", ch);
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
>stdio.h中定义了这三个宏
SEEK_SET代表文件指针的起始偏移量
SEEK_CUR代表文件指针当前的偏移量
SEEK_END代表文件指针的末尾偏移量
通过这三个宏，可以满足对参照物的需要

当前文件中的数据如下：
![alt text](image-26.png)
按照我们的预想，从起始位置移动2偏移量就是c。
![alt text](image-27.png)
Q: 这不是乱码吗？
A：啊这，文件和代码逻辑也没有问题啊?
 ##### 5.2 ftell(求当前偏移量)
 ```c
long int ftell(FILE* stream);
 ```
 给一个文件流，返回当前文件指针相对于起始位置的偏移量。
 ```c
 int main()
{

	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//使用文件
	//移动文件指针
	fseek(pf, 2, SEEK_SET);
	char ch = fgetc(pf);
	printf("%c\n", ch);
	printf("%d\n", ftell(pf));
	fseek(pf, 2, SEEK_CUR);
	ch = fgetc(pf);
	printf("%c\n", ch);
	printf("%d\n", ftell(pf));
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
![alt text](image-28.png)
Q：偏移量没有问题，可是还是打印乱码。
A：那么fseek函数应该没有问题，那么问题是不是printf呢？
![alt text](image-29.png)
Q：怎么会，明明指向的位置都不同却都是-1?
A：那只有可能是fgetc或者文件的问题了。我用fputs写入一些数据，看看能不能正常读取。
![alt text](image-30.png)
Q：使用fputc输入后的确打印结果正确了，但是偏移量却和
之前不同呢。
A:我想我知道原因了。调阅一下fgetc的返回值发现，如果读取失败，返回EOF，而EOF代表的值就是-1。
Q:那偏移量呢?
A:的确，还没有fgetc之前指向的偏移量是2，但是fgetc之后，会顺序向后移动一个字符啊。所以此时才计算偏移量就是3了。为什么是6也同理。
A：但是还是没有解决为什么读取文件会失败，之前读取的文件是我直接操作系统打开在里面写的，成功的时候是用fputs写的，是不是和这个有关系?
A: 的确与写入方式有关，我用fputs是以ASCII码表作为对应关系。我在操作系统写入时可能自动帮我变更成了一种叫UTF_8的对应关系，不同对应关系导致同样一个字符在不同对应关系下的序号不一样。
 ##### 5.3 rewind(让文件指针的位置回到文件的起始位置)
 ```c
void rewind(FILE* streaam);
 ```
此程序返回起始位置之后，读取应该是第一个字符a
```c
int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "w");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//使用文件
	fputs("abcdefg", pf);

	fclose(pf);
	pf = NULL;
	pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//使用文件
	//移动文件指针
	fseek(pf, 2, SEEK_SET);
	char ch = fgetc(pf);
	printf("%c\n", ch);
	printf("%d\n", ftell(pf));
	fseek(pf, 2, SEEK_CUR);
	ch = fgetc(pf);
	printf("%c\n", ch);
	printf("%d\n", ftell(pf));

	rewind(pf);
	ch = fgetc(pf);
	printf("%c\n", ch);
	printf("%d\n", ftell(pf));
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
![alt text](image-31.png)

#### 6.文本文件和二进制文件
数据保存到文件中的形式有两种。
一种叫二进制文件，把内存中的数据**不加修饰地保存到文件中**。简单来说就是内存中不管你存的是补码还是什么东西，怎么存的就怎么输出到文件。
另一种叫文本文件，把数据**转化为文本形式**保存。
打个比方，我要存10000这个数据。以二进制保存的话，就是
0000 0000 0000 0000 0010 0111 0001 0000
int类型，4个字节。
如果以文本形式的话，10000 -> '1' '0' '0' '0' '0'。5个字符，5个字节。
![alt text](image-35.png)
现在1的ASCII码值是49，0是48。
所以就是
0011 0001 0011 0000 0011 0000 0011 0000 0011 0000
1·············0·············0·············0·············0·············
一个数据在内存中是怎么存储的呢？
字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以使用二进制形式存储。
当我们面对使用二进制保存还是文本保存的时候，思考一下那种方式占用空间更小，计算时间更小。
比如保存10000这个数据显然4字节的二进制保存比5字符的文本保存要好。具体情况要具体分析。
```c
int main()
{
	FILE* pf = fopen("test.txt", "wb");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//写入
	int a = 10000;
	fwrite(&a, 4, 1, pf);
	//关闭 
	fclose(pf);
	pf = NULL;
	return 0;
}
```
![alt text](image-36.png)
10 27 00 00正是10000的二进制以小端存储的结果。数据在文件中保存也有字节序的不同。
A: 前面的00000000是一个地址，在这没有实际意义。
#### 7.文件读取结束的判定
##### 7.1 被错误使用的feof
Q: 为什么用这样的小标题？
A: 据说，feof就好比大相径庭这个成语，有普遍性的误解。
误解的点在于，使用feof的返回值，直接来判定文件是否结束。
规范的使用方法应该是，在已知文件结束的时候，判断文件结束的原因，是到文件末尾？还是读取失败？
所以应该先判断文件是否结束。
1. 文本文件读取是否结束，判断返回值是否为EOF(fgetc)或者NULL(fgets)
例如:
- fgetc判断是否为EOF.
- fgets判断返回值是否为NULL
2. 二进制文件的读取结束判断，判断返回值是否小于实际要读的个数。
例如:
- fread判断返回值是否小于实际要读的个数。
文本文件举例：
```c
int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "r");
		if (!pf)
		{
			perror("fopen");
			return 1;
		}
		//使用文件
		char c = 0;
		while (c = fgetc(pf) != EOF)
		{
			printf("%c ", c);
		}
		//判断文件结束的原因
		if (feof(pf))
		{
			printf("文件到达末尾");
		}
		else
		{
			printf("文件未到达末尾");
		}
		//关闭文件
		fclose(pf);
		pf = NULL;
	return 0;;
}
```
![alt text](image-37.png)
feof是读到文件末尾时，返回非零，否则返回0。
二进制文件例子
```c
int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "rb");
		if (!pf)
		{
			perror("fopen");
			return 1;
		}
		//使用文件
		int c = 0;
		while (fread(&c, 1, 3, pf) < 3);
		{
			printf("%c ", c);
		}
		//判断文件结束的原因
		if (feof(pf))
		{
			printf("文件到达末尾");
		}
		else
		{
			printf("文件未到达末尾");
		}
		//关闭文件
		fclose(pf);
		pf = NULL;
	return 0;;
}
```
还有一个判断文件位置错误的函数ferror：
![alt text](image-38.png)
当发现错误时返回非零，否则返回0.
#### 8.文件缓冲区
ANSIC标准采用“缓冲文件系统”处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。
使缓冲区数据流动的两个方法：
1. 缓冲区放满了
2. 刷新缓冲区，比如fclose就自带刷新缓冲区功能。
![alt text](image-39.png)
缓冲区是为了减轻操作系统负担，比如5条讯息，是传5次效率高还是5条一起传效率高？缓冲区的作用就类似于攒够了一起传。
下面不严谨证明缓冲区存在：
```c
int main()
{
	FILE* pf = fopen("test2.txt", "w");
	if (!pf)
	{
		perror("fopen");
		return 1;
	}
	fputs("abcdefg", pf);
	

	fclose(pf);
	pf = NULL;
	return 0;
}
```
已知fclose可以刷新缓冲区，调试过程中，运行代码到fputs之后，fclose之前，如果打开文件，没有内容，然后运行fclose之后有内容，则得证。![alt text](image-40.png)![alt text](image-41.png)
所以，要记得好好关闭文件，不然可能读写失败。
## 程序环境和预处理
- 程序的翻译环境
- 程序的执行环境
- 详解：C语言程序的编译+链接
- 预定义符号介绍
- 预处理指令#define
- 宏和函数的对比
- 预处理操作符#和##的介绍
- 命令定义
- 预处理指令#include
- 预处理指令#undef
- 条件编译
### 1.程序的翻译环境和执行环境
在ANSI C的任何一种实现中，存在两个不同的环境。
ANSI C - 国际c语言标准