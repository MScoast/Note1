*2025.8.21*
## 杂项
1. 之前我们打印错误信息一般是  
```c 
printf("%s\n",strerror(errno)); 
```
实际上可以使用函数perror
```c 
perror("错误是");
```
如果真的有错误，就会打印"错误是"+  :  + 错误信息。这就比之前方便许多。
2. "格式化"指的是数据在存储介质（如文件）和程序内存之间转换时，需要遵循的结构约定或表示规范。比如
```c
 // 格式化写入：将二进制数据转换为特定格式的文本
    fprintf(pf, "姓名：%s，年龄：%d，工资：%.2f\n", name, age, salary);
```
3. fprintf输入中文时出错，原因暂且不明。
4. Q：我们说printf是打印，scanf是输入，怎么到文件就反过来了？
A：实际上，printf是**从程序中读取数据**打印出来，scanf是**从外部读取数据到程序**；而把文件视为外部是不是就合理了。一般都是以程序作为第一人称。
![alt text](image-5.png)
#### 4.文件的顺序读写
![alt text](image.png)
可以看到，对于文件的读写，不仅仅有顺序的不同，还有一次读写多少，按什么形式读写的区别。
下面演示一下：
```c

#include<string.h>
#include<stdio.h>
#include<errno.h>
int main()
{
	FILE* pf = fopen("test.txt", "w");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//打开成功
	//读写文件


	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```
这就是使用一个文件的大概框架，包含打开，读写，关闭。
Q：为什么需要关闭，不关闭会怎么样？
A：不关闭会占用内存空间，而且不关闭文件可能会对里面的数据造成威胁。现在我们单独拿出读写文件的部分
##### fputc or fgetc
```c
//读写文件
//根据上表，我需要写文件，所以应该使用输出类的函数。
fputc('a',pf);

```
![alt text](image-1.png)
这里成功写入了'a'。关于文件写入具体运作方式我还发现了一些有意思的现象，关于使用文件整个过程不同阶段文件内容的变化，和同一程序多次输入和多次运行程序的不同，不过我猜之后会讲到。
解答：
A：以写入的方式打开文件，如果里面有内容，会 先把内容清空。
Q: 如果我不想清空呢？
A：请用'a'打开，也就是追加。
下面试试读文件吧
```c
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
//打开成功
//读写文件
//这里需要输入类函数
char c = fgetc(pf);
printf("%c\n",c);
```
因为这里需要读而不是写，所以就要更改打开文件的方式。
![alt text](image-2.png)
有意思的是，如果我先多次输入一些内容，然后多次读取，每次读取的内容不是第一个输入的内容，而是向后顺延。
```c
#define _CRT_SECURE_NO_WARNINGS
#include<string.h>
#include<stdio.h>
#include<errno.h>
int main()
{
	FILE* pf = fopen("test.txt", "w");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//打开成功
	//读写文件
	char i = 0;
	for (i = 'a';i <= 'z';i++)
	{
		fputc(i, pf);
	}
	//关闭文件
	fclose(pf);
	pf = NULL;
	pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//打开成功
	//读写文件
	//这里需要输入类函数
	char c = (char)fgetc(pf);
	printf("%c\n", c);	
	c = (char)fgetc(pf);
	printf("%c\n", c);
	c = (char)fgetc(pf);
	printf("%c\n", c);
	c = (char)fgetc(pf);
	printf("%c\n", c);
	c = (char)fgetc(pf);
	printf("%c\n", c);
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
![alt text](image-3.png)
我不禁设想，难道有一个神秘的计数器，能记录本次运行程序读的次数？
有一个要注意的点，如果读取失败，会返回EOF，所以可以加上一个判断EOF，以保证顺利运行。
##### fputs or fgets
下面试试写一行的数据，也就是fputs函数
![alt text](image-4.png)
```c
	FILE* pf = fopen("test.txt", "a");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//打开成功
	//读写文件
    fputs("hello world",pf);

	//关闭文件
	fclose(pf);
	pf = NULL;
```
注意这里用的是追加的打开方式。我运行了两次。
![alt text](image-6.png)
下面使用一次读取一行的函数fgets![alt text](image-7.png)
其实讲了3个这些函数大致规律也比较清晰了，指针是读写必须。读写失败返回值如果是指针就返回NULL，如果是整形就返回EOF。
```c
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//打开成功
	//读写文件
    char arr[13];//用于接收
    fgets(arr,5,pf);//看似是读5个字符，其实算上'\0'真正读了4个

	//关闭文件
	fclose(pf);
	pf = NULL;
```
![alt text](image-8.png)
##### fprintf or fscanf
讲这么多，这个文件读写函数还是只能以字符或字符串的形式，而要实现别的形式的读写，需要用格式化的读写。
fprintf是写文件，fscanf是读文件。
Q：我们说printf是打印，scanf是输入，怎么到文件就反过来了？
A：实际上，printf是**从程序中读取数据**打印出来，scanf是**从外部读取数据到程序**；而把文件视为外部是不是就合理了。
![alt text](image-9.png)
可以看出，相比于printf只多了一个文件指针。
```c
typedef struct S
{
	char name[13];
	int age;
}SS;

int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "w");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读写文件
	SS Z = { "zhangsan",21};
	fprintf(pf, "%s %d", Z.name, Z.age);

	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
再来试试格式化的读取
![alt text](image-10.png)
与scanf的参数也是非常的接近
```c
typedef struct S
{
	char name[13];
	int age;
}SS;

int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读写文件
	SS Z = {0};
	fscanf(pf,"%s %d",Z.name,&(Z.age));

	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
![alt text](image-11.png)
Q：为什么就识别成“zhangsan”和21，而不是“zhangsan 21”？
A：不知道啊

#### 流
![alt text](image.png)
Q：上图的最右边，适用于什么什么流是什么意思，流又是什么？
A：流可以理解成程序与外界信息的交界地。
如果对外界的读写如下图：
![alt text](image-12.png)
对于不同的对象，读写方式肯定不同，也就是说对于不同的对象，程序员需要用不同的方式读写，学习成本很高。
所以流出现了。
![alt text](image-14.png)
如图，通过流，就可以将我们输出或输入的数据转化为对应的形态。而流内部怎么转化，是底层帮我们实现的。
所以这些函数有的不仅仅面向于文件，而调用这些函数传入的用于读写的指针，就称为流。
![alt text](image-17.png)
所以我们现在使用的计算机，都是通过流进行读写（存疑）。流就像运河，开闸才能通行。我们为什么运行C程序时，能使用键盘，亮起屏幕，因为与这些相关的流默认开启
![alt text](image-15.png)
为什么使用文件要有一个打开的过程，这个过程就是开闸的过程。
按照上面的理论，fprintf是适应所有流的，那么是不是可以输出到屏幕上。
![alt text](image-16.png)
可以看到，之前使用fprintf是使用文件流，我改成了“stdout”屏幕的流，结果是打印到了屏幕上
> AI:
> 缓冲区与流的关系
您提出了一个很好的观察！缓冲区和流确实是密切相关但又有所区别的概念。它们经常一起工作，但并非完全相同的概念。
>- 缓冲区 vs. 流：区别与联系
>1. 本质
缓冲区 (Buffer)：内存中的一块区域
流 (Stream)：数据的抽象流动通道
>2. 功能
缓冲区 (Buffer)：临时存储数据
流 (Stream)：提供数据流动的路径和接口
>3. 比喻
缓冲区 (Buffer)：水池或水库
流 (Stream)：河流或管道
>4. 关注点
缓冲区 (Buffer)：数据的暂存和管理
流 (Stream)：数据的传输和方向
>5. 物理性
缓冲区 (Buffer)：具体的内存区域
流 (Stream)：抽象的概念接口
>- 缓冲区 (Buffer)
是实际的内存区域，用于临时存储数据
目的是平衡速度差异（如快速CPU与慢速I/O设备）
可以是硬件缓冲区或软件缓冲区
示例：键盘缓冲区、磁盘缓存、视频缓冲区
>- 流 (Stream)
是数据的抽象流动概念
提供统一的接口来处理各种输入/输出设备
关注的是数据流动的方向和方式
示例：标准输入流(stdin)、标准输出流(stdout)、文件流

##### fread 和 fwrite
这两个函数区别于其他函数适用于所有流。这两个函数只适用于文件流，也就是只能实现对文件的读写。而且不仅仅只能拿对文件读写，还只能以二进制的形式对文件读写。
![alt text](image-19.png)
![alt text](image-20.png)
```c
typedef struct S
{
	char name[13];
	int age;
}SS;
int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "wb");
	//因为要进行二进制的写，所以要使用"wb"的形式
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读写文件
	SS Z = { "zhangsan",21};
	fwrite(&Z, sizeof(SS), 1, pf);
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
然后打开文件
![alt text](image-18.png)
这正是因为txt文件是以字符形式打开，而我们写入的数据却是二进制形式，所以出现了乱码。
Q：那为什么"zhangsan"不是乱码？
A：因为"zhangsan"二进制和字符呈现的样子都一样。
Q：那么怎么读取里面的信息呢？
A：用二进制输入函数fread。
```c
typedef struct S
{
	char name[13];
	int age;
}SS;
int main()
{
	//打开文件
	FILE* pf = fopen("test.txt", "rb");
	//因为要进行二进制的写，所以要使用"wb"的形式
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读写文件
	SS Z = { 0 };
    //刚刚已经输入数据了
	fread(&Z, sizeof(SS), 1, pf);
    printf("%s %d",Z.name,Z.age);
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```
![alt text](image-21.png)
可以看到，fread的确提取出了我用二进制输出的数据。
Q：那么我以二进制形式读写和我以文本的形式读写有什么区别呢？
A：老师说以后会讲。
*2025.8.22*
对比一组函数
> fscanf / scanf / sscanf
> fprintf / printf / sprintf

 ![alt text](image-22.png)
 ![alt text](image-23.png)
 ##### sprintf 和 sscanf
 ```c
 int sprintf( char* str, const char* format, ...);
 ```
 将一个格式化的数据输出到一个字符串中。
 ```c
#include<stdio.h>
int main()
{
	int a = 13;
	char arr[8];
	sprintf(arr, "%d", a);
	printf("%s\n", arr);
	return 0;
}
 ```
此函数的本质是将格式化的数据转化为字符串。比如，一个整形13，在计算机眼中其实还有原反补等一系列的意义，使用这个函数相当于剥夺了它的意义，只保留“13”这个字符串。从 13 -> "13"。
![alt text](image-24.png)
当然也可以这样使用，本质都是一样的。
```c
int sscanf(const char* s, const char* format, ..);
```
从一个字符串数据中获取一个格式化的数据
刚刚sprintf的第一个参数是输出到哪里。
那么sscanf的第一个参数想必是从哪里输入，也就是从哪里获取数据。后面就是我们指定的格式,输入到某个地址指向的空间。也就是把"13" -> 13再把13存起来的过程。
```c
struct P
{
	char name[13];
	int age;
};
int main()
{
	struct P a = { "zhongyuanxia",17 };
	struct P b = { 0 };
	char buf[21];
	sprintf(buf, "%s %d", a.name, a.age);
	printf("%s\n", buf);
	sscanf(buf, "%s %d", b.name, &(b.age));
	return 0;
}
```
![alt text](image-25.png)
可以看到，成功从字符串buf中获取格式化的数据到我指定的空间了。这两个函数不针对任何流。
Q：为什么这么说？
A：我觉得是不管是获取数据的地方，还是输出数据的地方，都在程序内部完成，所以与外界连通的流无关。
所以，printf类函数与scanf类函数还真是相辅相成呢。
甚至说，自然界的一切视觉，都是字符串，听觉，触觉也是，我们通过 【脑】从自然界解读信息，还有将【脑】中的信息转化为语言，动作，的能力。
了解这些之后，关于sprintf与sscanf的应用场景也能想到，在一个程序内，如果有面向人类的字符串数据，就一定需要sscanf去解读成计算机理解的数据。同时如果要把计算机数据呈现给人类，就需要sprintf。

##### 通讯录（文件的版本）
